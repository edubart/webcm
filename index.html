<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>WebCM - Web Cartesi Machine</title>
        <meta
            name="description"
            content="Linux RISC-V virtual machine, powered by the Cartesi Machine emulator, running in the browser via WebAssembly."
        />
        <meta
            name="keywords"
            context="WebCM, Cartesi Machine, Virtual Machine, Linux, RISC-V, Virtualization, WebAssembly, Emulator"
        />
        <meta property="og:title" content="WebCM - Web Cartesi Machine" />
        <meta property="og:type" content="website" />
        <meta property="og:site_name" content="WebCM" />
        <meta
            property="og:image"
            content="https://edubart.github.io/webcm/social.png"
        />
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:site" content="@cartesiproject" />
        <meta
            name="twitter:title"
            content="WebCM - Linux virtualization in WebAssembly"
        />
        <meta
            name="twitter:description"
            content="Linux RISC-V virtual machine, powered by the Cartesi Machine emulator, running in the browser via WebAssembly."
        />
        <meta
            name="twitter:image"
            content="https://edubart.github.io/webcm/social.png"
        />
        <link rel="preconnect" href="https://cdn.jsdelivr.net" />
        <link rel="icon" href="favicon.svg" type="image/svg+xml" />
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.min.css"
        />
        <style>
            html {
                height: 100%;
            }
            body {
                margin: 0;
                height: 100%;
                background: #000;
                overflow: hidden;
            }
            #terminal {
                height: 100%;
                width: 100%;
                padding: 4px;
                box-sizing: border-box;
            }
        </style>
    </head>
    <body>
        <div style="display: contents">
            <div id="terminal"></div>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-web-links@0.11.0/lib/addon-web-links.min.js"></script>
        <!-- <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-webgl@0.18.0/lib/addon-webgl.min.js"></script> -->
        <script src="https://cdn.jsdelivr.net/npm/xterm-pty@0.11.1/index.min.js"></script>
        <script type="module">
            // Create xterm.js terminal
            const terminalElem = document.getElementById("terminal");
            const xterm = new Terminal({
                fontFamily: "monospace",
                fontSize: 14,
                fontWeight: 400,
            });
            xterm.open(terminalElem);
            // xterm.loadAddon(new WebglAddon.WebglAddon());
            xterm.loadAddon(new WebLinksAddon.WebLinksAddon());
            xterm.focus();

            // Create master/slave objects
            const { master, slave } = openpty();

            // Configure terminal for raw mode
            let termios = slave.ioctl("TCGETS");
            termios.iflag &= ~0x5eb; // ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL | IXON)
            termios.cflag &= ~0x130; // ~(CSIZE | PARENB)
            termios.lflag &= ~0x804b; // ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN)
            termios.cflag |= 0x30; // CS8
            termios.oflag |= 0x1; // OPOST
            slave.ioctl("TCSETS", termios);

            // Connect the master object to xterm.js
            xterm.loadAddon(master);

            // Make the terminal's size and geometry fit the size of #terminal
            const fitAddon = new FitAddon.FitAddon();
            xterm.loadAddon(fitAddon);
            fitAddon.fit();
            new ResizeObserver(function () {
                fitAddon.fit();
            }).observe(terminalElem);

            // Register Service Worker for /@// routing
            if ('serviceWorker' in navigator) {
                try {
                    const registration = await navigator.serviceWorker.register('./service-worker.js', {
                        scope: './'
                    });
                    console.log('Service Worker registered:', registration.scope);
                    await navigator.serviceWorker.ready;
                } catch (error) {
                    console.error('Service Worker registration failed:', error);
                }
            }

            // Download and initialize the emscripten module
            xterm.write("Downloading...\n\r");
            import initEmscripten from "./webcm.mjs";
            const Module = await initEmscripten({ pty: slave });


            function serializeHeaders(headers) {
                if (!headers) return '';
                if (headers instanceof Headers) {
                    return Array.from(headers.entries()).map(([k, v]) => `${k}: ${v}`).join('\n');
                }
                if (Array.isArray(headers)) {
                    return headers.map(([k, v]) => `${k}: ${v}`).join('\n');
                }
                return Object.entries(headers).map(([k, v]) => `${k}: ${v}`).join('\n');
            }

            async function prepareBody(body, headers) {
                if (body === null || body === undefined) {
                    return { data: null, contentType: null };
                }

                const encoder = new TextEncoder();
                const getContentType = () => headers instanceof Headers ? headers.get('Content-Type') : headers?.['Content-Type'];

                if (typeof body === 'string') {
                    return { data: encoder.encode(body), contentType: null };
                }
                if (body instanceof Uint8Array) {
                    return { data: body, contentType: null };
                }
                if (body instanceof ArrayBuffer) {
                    return { data: new Uint8Array(body), contentType: null };
                }
                if (body instanceof Blob) {
                    return { data: new Uint8Array(await body.arrayBuffer()), contentType: null };
                }
                if (body instanceof FormData || body instanceof URLSearchParams) {
                    const params = body instanceof FormData ? new URLSearchParams(body) : body;
                    return {
                        data: encoder.encode(params.toString()),
                        contentType: getContentType() || 'application/x-www-form-urlencoded'
                    };
                }
                // Default: JSON stringify
                return {
                    data: encoder.encode(JSON.stringify(body)),
                    contentType: getContentType() || 'application/json'
                };
            }

            // Fetch API for making HTTP requests inside the VM
            window.vmFetch = async function(urlOrRequest, options = {}) {
                let url, method, headers, body;
                if (typeof urlOrRequest === 'string' || urlOrRequest instanceof URL) {
                    url = urlOrRequest.toString();
                    method = (options.method || 'GET').toUpperCase();
                    headers = options.headers || {};
                    body = options.body || null;
                } else if (urlOrRequest instanceof Request) {
                    url = urlOrRequest.url;
                    method = (options.method || urlOrRequest.method).toUpperCase();
                    headers = new Headers(urlOrRequest.headers);
                    if (options.headers) {
                        const merge = new Headers(options.headers);
                        merge.forEach((v, k) => headers.set(k, v));
                    }
                    body = options.body !== undefined ? options.body :
                           (!urlOrRequest.bodyUsed ? await urlOrRequest.clone().arrayBuffer() : null);
                } else {
                    throw new TypeError('First argument must be a string, URL, or Request object');
                }

                let parsedUrl;
                try {
                    parsedUrl = new URL(url);
                } catch (e) {
                    throw new TypeError(`Invalid URL: ${url}`);
                }

                if (options.signal?.aborted) {
                    throw new DOMException('The operation was aborted.', 'AbortError');
                }

                // Preserve original hostname in Host header (all hosts resolve to 127.0.0.1 in VM)
                if (headers instanceof Headers) {
                    if (!headers.has('Host')) {
                        headers.set('Host', parsedUrl.host);
                    }
                    if (!headers.has('User-Agent')) {
                        headers.set('User-Agent', navigator.userAgent);
                    }
                } else {
                    if (!headers['Host'] && !headers['host']) {
                        headers['Host'] = parsedUrl.host;
                    }
                    if (!headers['User-Agent'] && !headers['user-agent']) {
                        headers['User-Agent'] = navigator.userAgent;
                    }
                }

                const { data: bodyData, contentType } = await prepareBody(body, headers);
                let headersStr = serializeHeaders(headers);
                if (contentType && !headersStr.toLowerCase().includes('content-type:')) {
                    headersStr = `Content-Type: ${contentType}\n${headersStr}`;
                }

                let uid;
                try {
                    Module._tempBodyData = bodyData;
                    uid = Module.ccall('vmFetch', 'number',
                        ['string', 'string', 'string', 'number'],
                        [url, method, headersStr || null, bodyData?.length || 0]
                    );
                } catch (e) {
                    Module._tempBodyData = null;
                    throw new TypeError('Failed to queue request: ' + e.message);
                }

                return new Promise((resolve, reject) => {
                    let aborted = false;
                    const timeout = options.timeout ?? 30000;

                    const cleanup = () => {
                        if (timeoutId) clearTimeout(timeoutId);
                        if (abortHandler && options.signal) {
                            options.signal.removeEventListener('abort', abortHandler);
                        }
                    };

                    const abort = (error) => {
                        aborted = true;
                        Module._cancel_reverse_request(uid);
                        Module._pendingResponses?.delete(Number(uid));
                        cleanup();
                        reject(error);
                    };

                    const timeoutId = timeout > 0 ? setTimeout(() =>
                        abort(new TypeError('Network request timeout')), timeout
                    ) : null;

                    const abortHandler = options.signal ? () =>
                        abort(new DOMException('The operation was aborted.', 'AbortError'))
                    : null;
                    if (abortHandler) options.signal.addEventListener('abort', abortHandler);

                    const poll = () => {
                        if (aborted) return;

                        if (Module._prepare_reverse_response(uid)) {
                            cleanup();

                            const responseData = Module._pendingResponses.get(Number(uid));
                            Module._pendingResponses.delete(Number(uid));

                            if (!responseData || responseData.status === 0) {
                                reject(new TypeError('Failed to fetch'));
                                return;
                            }

                            // Proxy network errors (502/504 with no body/headers) reject like fetch()
                            if ((responseData.status === 502 || responseData.status === 504) &&
                                (!responseData.body || responseData.body.length === 0) &&
                                responseData.headers.size === 0) {
                                reject(new TypeError('Failed to fetch'));
                                return;
                            }

                            const bodyStream = responseData.body?.length > 0 ? new ReadableStream({
                                start(controller) {
                                    controller.enqueue(responseData.body);
                                    controller.close();
                                }
                            }) : null;

                            resolve(new Response(bodyStream, {
                                status: responseData.status,
                                headers: responseData.headers
                            }));
                        } else {
                            setTimeout(poll, 10);
                        }
                    };
                    poll();
                });
            };

            window.webcm = {
                fetch: window.vmFetch,
                vmFetch: window.vmFetch
            };
            window.reverseProxyRequest = window.vmFetch;

            // Register this tab as VM owner for Service Worker routing
            if (navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({
                    type: 'registerVM'
                });
                console.log('Registered as VM owner');
            }

            // Unregister when page unloads
            window.addEventListener('beforeunload', () => {
                if (navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({
                        type: 'unregisterVM'
                    });
                }
            });

            // Handle vmFetch messages from Service Worker
            navigator.serviceWorker.addEventListener('message', async (event) => {
                if (event.data.type === 'vmFetch') {
                    const { url, method, headers, body } = event.data;
                    const port = event.ports[0];

                    try {
                        const options = { method, headers };
                        if (body) {
                            options.body = body;
                        }

                        const response = await window.vmFetch(url, options);
                        const responseBody = await response.arrayBuffer();

                        // Transfer ArrayBuffer instead of copying (zero-copy)
                        port.postMessage({
                            status: response.status,
                            statusText: response.statusText,
                            headers: Object.fromEntries(response.headers.entries()),
                            body: responseBody
                        }, [responseBody]);
                    } catch (error) {
                        console.error('VM fetch error:', error);
                        port.postMessage({
                            error: error.message || 'Failed to fetch'
                        });
                    }
                }
            });
        </script>
    </body>
</html>
